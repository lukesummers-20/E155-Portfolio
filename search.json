[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 6 Reflection\n\n\n\n\n\nLab 6 Reflection\n\n\n\n\n\nNov 19, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nProject Reflection 1\n\n\n\n\n\nFirst Reflection on Project Work\n\n\n\n\n\nNov 19, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7 Reflection\n\n\n\n\n\nLab 7 Reflection\n\n\n\n\n\nNov 19, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 7\n\n\n\n\n\nSeventh week reflection\n\n\n\n\n\nOct 18, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 6\n\n\n\n\n\nSixth week reflection\n\n\n\n\n\nOct 7, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 5\n\n\n\n\n\nFifth week reflection\n\n\n\n\n\nOct 7, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 4\n\n\n\n\n\nFourth week reflection\n\n\n\n\n\nSep 29, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 3\n\n\n\n\n\nThird week reflection\n\n\n\n\n\nSep 20, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 2\n\n\n\n\n\nSecond week reflection\n\n\n\n\n\nSep 13, 2024\n\n\nLuke Summers\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1\n\n\n\n\n\nFirst week reflection\n\n\n\n\n\nSep 6, 2024\n\n\nLuke Summers\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/ninth-post.html",
    "href": "posts/ninth-post.html",
    "title": "Lab 7 Reflection",
    "section": "",
    "text": "I was a little bit sad at the completion of this lab, as it marked the last of my lab work in E155. In the closing hours of my work on the lab, I was forced to reflect on my transformation as I completed each of the labs and see how far I have progressed. Over the past summer, I had fears of my ability to do this course so it was reassuring to be able to see that I could. I think a funny paradox about this lab was to me it was the most intellectually satisfying, but it produced the most lackluster result. The results of the lab were testbenches running successfully for simulation and a light on the development board lighting up to signify success in hardware. In comparison to the outputs of some of the other labs, this was pretty boring. Comparing this output to the task completed in the lab highlights the paradox, as I think this was the coolest lab we have done as it was dealing with a protocol that in this day and age affects so much of the population. It was also cool to see the MCU and FPGA interface with each other, as all the previous labs dealt solely with the FPGA or MCU. I think completing this lab has made me more excited for the final project, as I feel like it confirms I have at least some capabilities in digital design and thus has given me confidence about the project."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Week 1",
    "section": "",
    "text": "I found the first two weeks of review to be a nice refresher on the concepts I would need for the course. I think the biggest thing I needed some refreshers on were systemverilog syntax as it had been a while since I had used it. Early on in the lab, I ran into some struggles around this as I did not realize how much I had forgotten. I was forced to spend time re-familiarizing myself with verilog procedures and ididoms. This made me glad as after this lab I have now reinforced what I learned in E85, and moving forward I will be able to further expand this knowledge.\nAnother thing I found myself struggling with was the software used to develope our desings. In addition to forgetting some verilog, I also forgot a lot of the steps needed in order to do something like configure a design onto a chip or test a design in simulation. Some of the issues centered around needing to download and install the right packages and drivers, but this was something I was glad to do. I am not sure why I have always enjoyed trying to figure out non coding problems when running something, so I was glad to further widen my knowledge on various developement softwares."
  },
  {
    "objectID": "posts/third-post.html",
    "href": "posts/third-post.html",
    "title": "Week 3",
    "section": "",
    "text": "In this week of E155 I have enjoyed having to face a different kind of debugging that debugging software cannot offer. In building my finite state machine for lab 3, I have found difficulty in even what I thought were the more simple tasks of the lab. In my first attempt to move from simulation to hardware for the lab, I found my modules that worked completely as expected in simulation not even show the slightest signs of working in hardware. Although it would have been nice to create a working design for the lab on the first try, I was excited at the opportunity this gave me.\nI feel like in comparing how I have been thinking trying to debug my ciruit for the lab and how I usually think when trying to debug code, I have only found how different the processes are. There is an obvious sense of debugging strategies being resitricted without simple tools such as print statements, and that the goal is to check for function not for a status of function. I have enjoyed so far how these restictions have forced me to restructure my strategies towards debugging."
  },
  {
    "objectID": "posts/tenth-post.html",
    "href": "posts/tenth-post.html",
    "title": "Project Reflection 1",
    "section": "",
    "text": "I have found my time spent working on the project to be greatly enjoyable so far. My main tasks have been programming the game logic and 3D printing the chess pieces. The 3D printing has been easy as I did not have to design the pieces myself, so it has just been loading them into a slicer and printing them. The pieces I chose were not typical chess pieces, and they bring me a small amount of enjoyment as I think they look funny. The game logic programming has been where most of my thinking has gone, as my partner has been handling the board construction and light programming. The light programming was the part of the project we were most worried about, as we are using an LED strip we found in our lab so there was uncertainty associated with it. The game logic programming has been enjoyable to me as I feel like it is the biggest crossover of my work in E155 and the rest of my work as a computer science major. I have enjoyed applying some of the concepts I have learned in my more software focused classes to this specific application of a program on an MCU. I am excited to finish up the game logic and start putting everything together, including the board, pieces, and interface with the FPGA/MCU"
  },
  {
    "objectID": "posts/sixth-post.html",
    "href": "posts/sixth-post.html",
    "title": "Week 6",
    "section": "",
    "text": "In this week of E155 I learned to gain a kind of joy from reading the MCU reference manual. Upon first starting to think about the lab, I thought of various different ways to use the encoder signals to measure the speed. I realized that the main task boiled down to using the encoder signals to track the distance the motor traveled, and using a timer to create time intervals to check the distance to get a speed. I spent a majority of the time on the lab reading through the reference manual, especially in the advanced timer (timer 1) section. I ended up using the advanced timer in encoder mode, but some other options I considered were using timers in input captur mode to track the time between each signal or using a timer with the input exclusive, turned on to track the offset in time between the signals, or using the external interrupts in the MCU to create interrupts on the encoder signals. I ended up choosing the encoder mode method because this mode converted the timers counter value basically into a position for the motor if configured correctly. The counter also counted on bothing falling and rising edges of both signals, so there were four counts for every 1 encoder pulse. This meant the positional resolution on the motor was four times higher than tracking position by every encoder pulse. I also feel like another benefit of this method was being able to use another timer to track timer, and only access this position value on interrupts. This means that while the motor is running, the position timer will count and track the position regardless of what the cpu is doing, such as calculating a new speed or displaying it. The second timer will create an interrupt every 0.25 seconds, and thus the position can be read as close to 0.25 seconds as possible. Thus the distance tracking, time tracking, and speed calculations/handling can be done more simultaneously, which increases the accuracy of the two time dependent tasks.    \nIn class we reviewed/learned about SPI and UART. It was nice to get back into these topics, and starting to think about them caused excitement within me for getting to learn how to use them in the upcoming labs. I also started thinking about my final project with my partner more this week, and I am already very excited with our idea. We plan to make a chess board that lights up the squares a piece can move to if you pick it up. There are other functionalities like making the board light up squares with a capturable piece red, and if we find early success maybe even something like a game tracker, where the board tracks the game and can say who won and lost. A cool very big stretch idea Prof. Brake had was to somehow find an embedded chess computer and then interface the board with it so that one could play the chess computer by making moves and then having the board light up the computers desired move. This is probably out of the scope of our final project, but would be a cool idea to return to in the future."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab the MCU was used to drive a small speaker to play short tunes. One of the basic timers on the MCU were used to generate the square wave for the speaker, and the other was used to handle generating the square wave for a certain duration. The design implimented played “Fur Elise” and the melody of “Blue(Da Ba Dee)”."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab the MCU was used to drive a small speaker to play short tunes. One of the basic timers on the MCU were used to generate the square wave for the speaker, and the other was used to handle generating the square wave for a certain duration. The design implimented played “Fur Elise” and the melody of “Blue(Da Ba Dee)”."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 4: Digital Audio",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe square wave was generated using one of the basic timers on the MCU. With how the RCC clock configuration register was set, the clock that is fed into the timer was at a frequency of 1 Mhz. This was done by setting bits 4-7 of the RCC_CFGR register to ‘1001’. The prescaler on the clock was set to 1 as the input clock was already the desired frequency. In order to generate the square wave, the auto reload register of the timer was set so that counter overflow would happen at twice the desired frequency. The square wave was then made by clearing the timers status flag, writing one to the pin, waiting for one period of the clock to have counter overflow, reseting the timer status flag, writing 0 to the pin and waiting for another period of the timer, and then repeating. Since counter overflow will occur at twice the desired frequency, the output pin will have a wave that is at the desired frequency.     The other basic timer was then used to output this square wave for the desired duration of time. The prescaler of this timer was set so that the clock frequency of the timer was 1 Khz. With a frequency of 1 KHz the counter of this timer would be incrementing once every millisecond, which means the auto reload register of the timer could be set to the desired number of milliseconds and then the counter overflowing could be used to trigger the stoppage of the square wave. In this way the two timers could be used to generate square waves at specific frequencies for a certain number of milliseconds which was used to drive the speaker. The design was tested by using the oscilliscope to measure the frequency of an output wave to compare it to the desired frequency of the design. The circuit included the MCU, a LM386 audio amplfier, a small speaker, and a potentiometer for volume control. It also used two switches to trigger the playing of each song.    \n   \nThe MCU has an onboard timer that is more robust that could have been used to generate a PWM signal that is connected directly to a pin. In creating the design for this lab, generating a square wave with this method was tested and I found it to be about as accurate as the method I used with two basic timers, so I chose the simplicity of using the basic timer."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4: Digital Audio",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe sourcecode for the project can be found in the Github repository.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic\n\n\n\nFigure 1 shows the circuit for the design.\n\n\nCalculations\n\n\n\n\n\n\nFigure 2: Frequency Accuracy\n\n\n\nFigure 2 shows the calculations done for the accuracy of the design at outputing a wave in the range of 220 Hz to 1000 Hz. Since the design is within the standard for 220 Hz and 1000 Hz, it will be within the standard for all frequencies in between.\n\n\n\n\n\n\nFigure 3: Frequency and Duration Range\n\n\n\nFigure 3 shows the calculations done for the frequency and duration ranges. The minimum duration is 0 ms and the maximum is just the maximum that the ARR can be set to, which is 65,535 because the ARR has 16 accessible bits. Thus the maximum duration supported is 65.545 seconds. The design could be changed to increase this value by changing the clock frequency of the timer. The design supports a freqency of 0, but that just outputs nothing. The minimum frequency it can generate is 7.6 Hz, as the ARR can be set to 65,535 which would produce counter overflow at 15.2 Hz. The output frequency would then be 7.6 Hz. The maximum is just the timer clock frequency which is 1 Mhz. The timer clock frequency could be changed to achieve frequencies outside of this range if desired."
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 4: Digital Audio",
    "section": "Results and Discussion",
    "text": "Results and Discussion"
  },
  {
    "objectID": "labs/lab4/lab4.html#oscilliscope-reading",
    "href": "labs/lab4/lab4.html#oscilliscope-reading",
    "title": "Lab 4: Digital Audio",
    "section": "Oscilliscope Reading",
    "text": "Oscilliscope Reading\n\n\n\n\n\n\nFigure 4: Oscilliscope Reading for 220 Hz\n\n\n\nFigure 5 shows an oscilliscope reading of the output pin when trying to output a 220 Hz signal. The ARR was set to 2272 so that counter overflow would occur at twice the desired frequency, as the design would toggle the pin at half of the frequency of counter overflow. Due to the system not being to function instantaneously the output signal was a little slower than desired but within the requirements.\n\n\n\n\n\n\nFigure 5: Oscilliscope Reading for 1000 Hz\n\n\n\nFigure 5 shows an oscilliscope reading of the output pin when trying to output a 1000 Hz signal. The ARR was set to 500 so that counter overflow would occur at twice the desired frequency, as the design would toggle the pin at half of the frequency of counter overflow.\n\nExample of Design\n\nThe video above shows the design playing both of the desired songs, along with the potentiometer being used to control the volume."
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nThe MCU’s on board timers were used to generate certain frequencies of square waves for certain durations in order to drive a small speaker. I spent a total of 10 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, the FPGA was used to drive two seven segment displays using only one set of logic for the display outputs. The FPGA took inputs from two four input DIP switches and displayed the two inputs on two seven segment displays and their sum using seperate LEDs. The main task of this lab was to drive the displays using one seven segment display signal decoder."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, the FPGA was used to drive two seven segment displays using only one set of logic for the display outputs. The FPGA took inputs from two four input DIP switches and displayed the two inputs on two seven segment displays and their sum using seperate LEDs. The main task of this lab was to drive the displays using one seven segment display signal decoder."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe task of driving the two displays was done by using a module to multiplex the switch inputs and then feed this signal into the seven segment display decoder module. The on-board high-speed oscillator was used to produce a clock signal, and then the input multiplexer module would then on every positive edge of the clock switch between outputing each switch signal. This output signal was then inputed into a module that decoded the signal into the corresponding signal to drive the LEDs of the display. This LED display signal was one of the outputs of the FPGA in the circuit. Two enable signals were also output for transistors used to drive the displays. The sum of the two inputs was calculated in another module and this sum signal was also outputed by the FPGA. A testbench was created for the adder and input multiplexer modules to test their function in QuestaSim. The seven segment display decoder module is from a previous lab where it was already tested and it is unreasonable to test the oscillator signal in simulation.\nThe circuit that was made with the FPGA included the two seven segment displays, five LEDs for the sum, and transistors for driving the seven segment displays. The seven segment displays would draw too much current from the FPGA pin, so a transistor was used to help supply current. Two PNP transistors were used, which were switched on and off by the enable signals to drive displaying either digit."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe sourcecode for the project can be found in the Github repository.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block Diagram\n\n\n\nFigure 1 shows the design implimented on the FPGA.\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic\n\n\n\nFigure 2 shows the circuit for the design. The LEDs were connected to current limiting resistors of 100 \\(\\Omega\\). These resistor values were solved for by solving for R in V = IR with the voltage found from the part data sheets and a desired current of around 8 mA found from the FPGA data sheet. With voltages of 1.2 and 1.3, 100 \\(\\Omega\\) resistors gave a current slightly above 8 mA. The same calculation was done using 3.3V to find the resistance of the resistors for the transistor base signal."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\n\n\n\nFigure 3: Adder Testbench\n\n\n\n\n\n\n\n\n\nFigure 4: Input Multiplexer Testbench\n\n\n\nThe design met all intended objectives. Figure 3 shows the signals produced by the testbench for the adder module. The expected output is the same as the output, so the adder module was succesful in simulation. Figure 4 shows the signals produced by the testbench for the input multiplexer module. The output signals replicate the expected output signals as the clock cycles, showing this module succesfully multiplexes the signals in simulation.\n\n\nExample of Seven Segment Displays\n\n\n\n\n\n\nFigure 5: Display Example\n\n\n\nIn addition to working in simulation, the design also worked in reality. Figure 5 shows an example of the circuit working. Both switches were inputing ‘1000’, which is 8 as seen on the two seven segment displays. The sum is thus 16 or ‘10000’ which is shown by the fifth LED being lit up on the LED bar in the bottom right of the photo."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThe FPGA was used two time multiplex two input signals to drive two seven segment displays in addition to displaying their sum. I spent a total of 12 hours on this lab."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: Advanced Encryption Standard Hardware Accelerator",
    "section": "",
    "text": "In this lab a hardware accelerator for the Advanced Encryption Standard algorithm was designed for a FPGA to carry out 128 bit encryption. An MCU was used to send a key and plain text to the FPGA via SPI for encryption and then confirmed that the encryption was done correctly."
  },
  {
    "objectID": "labs/lab7/lab7.html#introduction",
    "href": "labs/lab7/lab7.html#introduction",
    "title": "Lab 7: Advanced Encryption Standard Hardware Accelerator",
    "section": "",
    "text": "In this lab a hardware accelerator for the Advanced Encryption Standard algorithm was designed for a FPGA to carry out 128 bit encryption. An MCU was used to send a key and plain text to the FPGA via SPI for encryption and then confirmed that the encryption was done correctly."
  },
  {
    "objectID": "labs/lab7/lab7.html#design",
    "href": "labs/lab7/lab7.html#design",
    "title": "Lab 7: Advanced Encryption Standard Hardware Accelerator",
    "section": "Design",
    "text": "Design\nThe design consisted of modules that carried out the substition, row permutation, column transformation, and combination with the expanded key. The table for the byte subsitution was loaded into the FPGA’s block RAMs. The subsitution module then could simpily make the subsitution for each byte when necessary. The row permutation module was combinational logic that carried out the required moves. The column transformation module performed a matrix multiplaction on the columns with a fixed matrix. The multiplacation permformed was multiplaction within GF(\\(2^8\\)). The combination with the expanded key module consisted of an XOR with the portion of the expanded key corresponding to a certian round. For 128 bit encryption, the 4 word key is expanded into a 44 word key. Because the 4 words of the key that correspond to a round only depend on the 4 words of the last round’s key, key expansion could be performed in parrallel to each round of encryption. Before the encryption rounds start, the 4 original key words are XORed with the plaintext, essentially serving as round 0. This means the key expansion module in this round could calculate the words for the next round during this, and this process continued as each subsequent round occurred.    \nWithin the core module for the encryption, the above modules were connected together to create the datapath for the encryption. The core module made use of enabled registers and multiplexers to control the data signals to accurately carry out each round. The module took a load signal as input, and when asserted began the encryption with round 0. In round 0, the key was fed into the key expansion module and the plain text was fed into the key compination module with the key. For rounds 1-9, the key was updated and along with the input to the datapath. On round 10, the column transformation module was skipped in the data path. After round 10 was completed, a output done signal was asserted to signal the the encryption was complete.    \nThe MCU was used to give the FPGA a key and plain text to encrypt via SPI and then recieved the encrypted text back via SPI. The MCU then lit up an LED to signify the encryption was done, and lit up one LED to show that this was succesful or another one if unsuccessful. The top level AES module for the FPGA contained the AES core module and a module to carry out the SPI transactions. When the key and plain text were recieved, the SPI module would assert a load signal to the core module to start the encryption. When the FPGA was done with the encryption, the SPI module would send the encrypted text back to the MCU when the done signal was asserted.    \nPrior to the design being tested in hardware, it was tested in simulation. Test benches were written and ran for each module within the data path. Then test benches were ran on the core and SPI modules to confirm the encryption and SPI transaction worked as expected in simulation. Once these test benches ran successfully, the design was programmed in hardware and used the LEDs to show the resulting success of the encyrption. A logic analyzer was used to confirm the correctness of the SPI transactions taking place."
  },
  {
    "objectID": "labs/lab7/lab7.html#technical-documentation",
    "href": "labs/lab7/lab7.html#technical-documentation",
    "title": "Lab 7: Advanced Encryption Standard Hardware Accelerator",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe sourcecode for the project can be found in the Github repository.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic\n\n\n\nFigure 1 shows the circuit for the design.\n\n\nBlock Diagrams\n\n\n\n\n\n\nFigure 2: AES Core Block Diagram\n\n\n\n\n\n\n\n\n\nFigure 3: Key for Core Signals\n\n\n\nFigure 2 shows the block diagram for the AES core implimented on the FPGA. Figure 3 shows the logic for the enable, reset, and select signals in the core module.\n\n\n\n\n\n\nFigure 4: AES Top Level Module BLock Diagram\n\n\n\nFigure 4 shows the block diagram for the top level AES module implimented on the FPGA."
  },
  {
    "objectID": "labs/lab7/lab7.html#results-and-discussion",
    "href": "labs/lab7/lab7.html#results-and-discussion",
    "title": "Lab 7: Advanced Encryption Standard Hardware Accelerator",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design was succesful in carrying out encryption according to the AES standard. All modules passed their corresponding test benches in simulation, and the design was able to fit on the FPGA. The FPGA design successfully communicated with the MCU in hardware. Upon a reset to the MCU, which causes it to resend the plain text and key and wait for the cipher text, the light indicating success was lit when the done light was lit. This showed the design worked in hardware.\n\nExample SPI Transaction\n\n\n\n\n\n\nFigure 5: SPI Transaction\n\n\n\n\n\n\n\n\n\nFigure 6: Zoomed View of Transaction\n\n\n\nFigure 5 shows an example SPI transaction read on the logic analyzer. Figure 6 shows a zoomed in view of this transaction. The decoded bytes on the CIPO line in the picture show the first 5 words of the cipher text being sent out by the FPGA. These words match the expected values for the first five words."
  },
  {
    "objectID": "labs/lab7/lab7.html#conclusion",
    "href": "labs/lab7/lab7.html#conclusion",
    "title": "Lab 7: Advanced Encryption Standard Hardware Accelerator",
    "section": "Conclusion",
    "text": "Conclusion\nThe design on the FPGA successfully carried out encryption according to the AES standard and successfully communicated with the MCU to carry out an encryption. I spent 12 hours on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1:FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, an FPGA and MCU were assembled on a board and tested to ensure functionality. First, all of the components were souldered onto the board. Then the FPGA was used to take input from the 4 input DIP switch and power 3 on-board LEDs and a seven segment display. The FPGA powered one of the LEDs to blink at 2.4 Hz, one to perform an exclusive or of the first two switch inputs, and one to perform an and of the second two switch inputs. The FPGA also performed logic to display the corresponding hexadecimal digit to the input from the four switches."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1:FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, an FPGA and MCU were assembled on a board and tested to ensure functionality. First, all of the components were souldered onto the board. Then the FPGA was used to take input from the 4 input DIP switch and power 3 on-board LEDs and a seven segment display. The FPGA powered one of the LEDs to blink at 2.4 Hz, one to perform an exclusive or of the first two switch inputs, and one to perform an and of the second two switch inputs. The FPGA also performed logic to display the corresponding hexadecimal digit to the input from the four switches."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1:FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe task of blinking an LED at 2.4 Hz was completed by making use of the on-board high-speed oscillator (HSOSC) from te iCE40 UltraPlus primative library. This library was used to make a signal that oscillated at 48 MHz. A counter that counted to 10,000,000 was then used to generate a signal that oscillated at 2.4 Hz. This signal was then used to drive one on-board LED. The second two LEDs were driven by combinational logic done on the FPGA. This was completed using simple assign statements. The seven segment display was driven by a module that took the inputs from the 4 switches and did the combinational logic to drive the pins of the seven segment display. This was completed using a case statement. The seven segment display used was a common annode one, which meant that power was driven to it through a common anode and then the display was controlled by driving the corresponding cathode pins of the seven segment display to 0. These pins were connected to the FPGA and a current limiting resistor. This was tested with a simulation of the systemverilog in ModelSim. A testbench module was created to instanstiate an instance the logic design for the FPGA, and then apply test vectors to ensure that the design functions as expected. Within the repository the sim folder contains the systemverilog test bench. Because of how the timing in the simulation works, it is not reasonable to test the LED blinking at 2.4 Hz in simulation. Thus, the blinking LED was tested using an oscilloscope to measure the frequency of the LED signal."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1:FPGA and MCU Setup and Testing",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe sourcecode for the project can be found in the Github repository.\n\nFigure 1: Block Diagram\n Figure 1 showcases the design implimented on the FPGA, with the lab1 module containing the oscillator and seven segment display logic modules.\n\n\nFigure 2: Schematic\n Figure 2 shows the circuit for the lab. The LEDs were connected to current limiting resistors of 1k \\(\\Omega\\) for the on-board LEDs and 100 \\(\\Omega\\) for the seven segment display LEDs to ensure the circuit did not draw too much current from the FPGA pins. The resistor values for the seven segment display were found by solving for R in V = IR with the voltage and desired current of the circuit. The voltage drop of the LED was 1.5, and the desired current was 5-20 mA. Solving for R with 5 and 20 mA, we see that the desired resistor is between 75 and 300 \\(\\Omega\\)."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1:FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n The design was succesful both in similation and in reality. The systemverilog design passed the test bench as the output signals match the expected output signals and the test bench module ran succesfully with no errors. Moving the design into a circuit, the circuit seen in Figure 2 was succesful in producing the desired LED signals. This was seen through an oscilloscope reading and observation of the other LEDs.\n\nFigure 3: Oscilloscope Reading\n Figure 3 shows a picture taken of an oscilloscope reading of the signal blinking at 2.4 Hz for one of the on-board LEDs.\n\n\nFigure 4: Testbench Simulation\n Figure 4 shows a screenshot of the waves produced by the test bench simulation.\n\n\nFigure 5: Example of on Board LEDs\n Figure 5 shows a picture of the board with the input switches set to an inbut of ‘1101’. Since the exclusive or of the 2 least significant bits and the and of the 2 most significant bits are both true, both LEDs are lit. The third LED was caught at a point of being not lit.\n\n\nFigure 6: Example of Seven Segment Display\n Figure 6 shows the seven segment display on the same input as seen in the previous figure. ‘1101’ corresponds to ‘d’ in hexadecimal, and the representation for ‘d’ chosen is shown in the figure on the seven segment display."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1:FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nThe design performed the desired logic in simulation and in a circuit. This proved all the components of the circuit board assembled to be functioning. I spent a total of 18 hours on this lab."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab the MCU was used to interface with a DS1722 temperature chip to read temperatures and then sent the temperature reading to an ESP8266 chip that hosted a webpage that showed the temperature. Upon a request on the web server, the MCU would interface with the DS1722 via SPI, convert the SPI values into a temperature, and then send the updated webpage to the ESP8266 via UART. The web server could also be used to control an LED on the developement board. The SPI transactions were debugged using a logic analyzer on an oscilliscope."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab the MCU was used to interface with a DS1722 temperature chip to read temperatures and then sent the temperature reading to an ESP8266 chip that hosted a webpage that showed the temperature. Upon a request on the web server, the MCU would interface with the DS1722 via SPI, convert the SPI values into a temperature, and then send the updated webpage to the ESP8266 via UART. The web server could also be used to control an LED on the developement board. The SPI transactions were debugged using a logic analyzer on an oscilliscope."
  },
  {
    "objectID": "labs/lab6/lab6.html#design",
    "href": "labs/lab6/lab6.html#design",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Design",
    "text": "Design\nThe STM32L432KCUx MCU has onboard peripherals that can enact SPI and UART. The onboard USART peripheral was used to communicate the webpage to the ESP8266. In the loop of code that the MCU continuously ran, the MCU would first wait for a server request to come in over UART. The MCU would then enact an SPI transaction with the temperature chip to get the most recently stored temperature and convert the CIPO register values into a single float of the temperature. The loop would also update the status of the LED upon the request. The MCU would then send the updated wep page back to the ESP8266 via UART. The ESP8266 created a wifi network and displayed the network on a network private IP address.\n\n\nThe DS1722 supports 8, 9, 10, 11, and 12 bit resolution values for reading the temperature. The web page had buttons to contorl the resolution of the temperature readings taking place. The chip had two 8 bit registers to store the temperature reading value. The first register contained the 8 bits of the temperature that were the whole number value of the temperature, stored in the register as an 8 bit two’s compliment value. The second register was used to store the fractional portions of the temperature reading if the resolution was above 8 bits. The DS1722 supported continuous and ‘one shot’ temperature reading modes, where in continuous mode the temperature registers were continually updated with the most recent temperature reading and in one shot mode the registers would be updated with a temperature reading when prompted by interfacing with the chip’s configuration register. The design used the continuous reading mode. Due to the temperature reading taking some amount of time depending on the resolution, there was a bit of latency between updating the resolution and when the temperature reading would be in that resolution. The configuration register was also used to control the resoultion of the temperature readings takng place."
  },
  {
    "objectID": "labs/lab6/lab6.html#technical-documentation",
    "href": "labs/lab6/lab6.html#technical-documentation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe sourcecode for the project can be found in the Github repository.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic\n\n\n\nFigure 1 shows the circuit for the design.\n\n\nSPI Configuration\nThe MCU was configured as the controller for the SPI transactions with the temperature chip as the peripheral. The CE signal was controlled manually in software. The data size for the transactions was 8 bits. The peripheral divided the input clock signal by 256. The phase was set so that data capture occurred on the second clock transition. The temperature chip supported both types of clock polarity, and an idle low clock polarity was used."
  },
  {
    "objectID": "labs/lab6/lab6.html#results-and-discussion",
    "href": "labs/lab6/lab6.html#results-and-discussion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design was successful at interfacing with the temperature chip to make temperature readings, control the LED, and send the information to an internet accessable webpage. The web page was successful in controlling the LED and the resolution of the temperature readings taking place. Due to the time required to calculate a temperature reading, whenever the status would change it would take multiple refreshes for this to be reflected in the temperature. More complex web developement techniques could have been used to make this process smoother, but that was out of the scope of the lab. A can of compressed air turned upside down was used to create negative temperature values on the chip, and the design was successful in handling these negative temperatures.\n\nExample SPI Transaction\n\n\n\n\n\n\nFigure 2: SPI Transaction\n\n\n\nFigure 2 shows an example SPI transaction read on the logic analyzer. The first two transactions configure the chip to make a 12 bit temperature reading. The second two read the whole number temperature value register. The last two read the fraction temperature value register."
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Conclusion",
    "text": "Conclusion\nThe MCU succesfully interfaced with the two peripheral chips using UART and SPI to create a webpage to control and show the LED and temperature status. I spent around 30 hours on this lab, but this was massively inflated by my shortsightedness about the unreliability of the logic analyzer head and wiring my output to pin 6 on the FPGA as apposed to the desired pin A6 on the MCU."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab the MCU was used to drive a quadrature encoder that was used to read the speed of a brushed DC motor. The advanced timer of the MCU was used in encoder interface mode to keep track of the position of the motor and a basic timer was used to generate an interrupt every 0.25 seconds that was used to track the change in position over the 0.25 seconds. A speed could then be calculated and averaged with the previous two speed to produce a speed reading. The design was succesful in reading the speed of the motor and displaying it."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab the MCU was used to drive a quadrature encoder that was used to read the speed of a brushed DC motor. The advanced timer of the MCU was used in encoder interface mode to keep track of the position of the motor and a basic timer was used to generate an interrupt every 0.25 seconds that was used to track the change in position over the 0.25 seconds. A speed could then be calculated and averaged with the previous two speed to produce a speed reading. The design was succesful in reading the speed of the motor and displaying it."
  },
  {
    "objectID": "labs/lab5/lab5.html#design",
    "href": "labs/lab5/lab5.html#design",
    "title": "Lab 5: Interrupts",
    "section": "Design",
    "text": "Design\nIn encoder interface mode, the advanced timer can take inputs from pins on two channels that control the timer counter. The quadrature encoder will send out two slightly offset waves when the motor is spinning, and when the motor switches direction the signal that was second becomes the first signal and vice versa. The timer counts up while the two input signals coming in are slightly offset, and counts down when they are slightly offset in the other direction. If the motor is not moving or oscillating short amounts, the counter stops or oscillates slightly. Thus, the counter of the timer keeps track of the motor position. This means that while we have the encoder connected to a timer in encoder mode, the counter of the timer represents the motors position, with the position of the motor when the counter starts counting being the relative zero.    \nThis can be used to find the motors speed because another timer can be used to generate an interupt every 0.25 seconds, and the handler of the interrupt can capture the counter value of the encoder timer. Using an interrupt for this task as opposed to manually polling is far more accurate. When the interupt occurs, the process is halted and the ISR takes over. This means that there will be less latency between when 0.25 seconds has passed and when the counter value is captured than if polling was used, as if polling was used then if the end of the 0.25 seconds was not at a time when the MCU was checking the timers status, then the counter value captured would be from slightly after the 0.25 seconds was over. Because the MCU can transfer control to the ISR once the counter overflows, the counter value is a lot more accurate to the 0.25 second mark.    \nEverytime a new value is captured, the distance moved in the last 0.25 seconds could be calculated and then used to calculate a new speed, which was then averaged with the previous two speeds to produce the final motor speed reading. This could then be displayed to the standard output terminal. The circuit consisted of the MCU and the motor. The quadrature encoder was drivin by the +5V pin on the MCU and the signals were input to pins A8 and A9. The motor was driven by a power supply as the MCU does not produce enough current to drive it."
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5: Interrupts",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe sourcecode for the project can be found in the Github repository.\n\nFlow Chart\n\n\n\n\n\n\nFigure 1: Signal Flow Chart\n\n\n\nFigure 1 shows the flow chart for the program control of the design. After the set up steps for the peripherals are completed, the main loop checks if the update variable is set as 1. If it is set, then it calculates the speed, displays it, and resets the update variable to 0. If it is not set, it does nothing. When a counter overflow interrupt occurrs in the timer used to measure the time step, control is transfered from the main loop to the timer 7 interrupt service routine, which just captures the motor position and direction and sets the update variable to 1. Control is then transfered back to the main loop.\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic\n\n\n\nFigure 2 shows the circuit for the design.\n\n\nCalculations\nThe distance calculation was done by subtracting the position 0.25 seconds ago from the current posiiton, and then adding a loop offset if necessary. Because the position value eventually has to loop back around to 0, if the encoder timer’s counter value resets to zero within the time step an offset has to be added to account for this. If the counter is upcounting and this occurrs, than the loop offset is added to the distance value and if the counter was downcounting when this occurrs the loop offset is subtracted. The loop offset value is just the maximum value of the counter. The speed was then calculated by dividing the distance by 0.25 seconds. Since the distance is directly calculated by timer values, the result will be in the units of timer counts per second. In order to get this in revolutions per second, the value is divided by the number of counts per rotation. The motor creates 120 pulses per rotation, and the timer will count for both falling and rising edges of both signals so after the counter counts 480 times, the motor has completed one rotation. After dividing the speed by 480 it is the speed of the motor in revolutions per second. The speed was then continually averaged with the previous two for the final speed."
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "Lab 5: Interrupts",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nExample of Design\n\nThe design was succesfull in acheiving its desired functionality. The video above shows the design reading the speed of the motor at various voltages. The design becomes more accurate as the speed is slowed, but is still accurate to around the tenth of a rotation per second through a +20V input. The good accuracy of the reading is due to the position counter incrementing 4 timers per motor pulse, which increases the accuracy of the position reading 4 fold. With a more accurate position reading that is read as close to the 0.25 second time step mark as possible, the resulting speed calulated is also very accurate. When the direction of the motor was switched, the design succesfully displayed a negative speed."
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nThe MCU succesfully read a quadrature encoder to read the speed of the connected motor. I spent 13 hours on this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab the FPGA was used to take input from a 4 \\(\\times\\) 4 keypad and then displayed the 2 most recently pressed digits on a dual seven segment display. Recieving the input from the keypad was done using a finite state machine, and then the display was drivin with the same modules used in Lab 2. Thus the main task of the lab was designing the FSM to correctly read inputs from the keypad scanner."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab the FPGA was used to take input from a 4 \\(\\times\\) 4 keypad and then displayed the 2 most recently pressed digits on a dual seven segment display. Recieving the input from the keypad was done using a finite state machine, and then the display was drivin with the same modules used in Lab 2. Thus the main task of the lab was designing the FSM to correctly read inputs from the keypad scanner."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe task was completed using a finite state machine and a decoder to decode the output signals from the FSM. The onboard high speed oscillator was used to produce the clock signal to drive the other modules. A synchronizer module was used to synchronize the inputs from the keypad columns for the FSM. The finite state machine that read the input from the keypad scanner would continuously power one row of the scanner at a time until a button was pressed, connecting a row to a column and powering one of the column bits. The design implimented would register one key press if a key was held, and it would ignore any other keys pressed while a key was held. In order to ignore switch bouncing, the FSM design had two hold states for the signal to bounce whenever a button was pressed. This meant that the system had to be clocked at a frequency slow enough to where 2 cycles would be enough to handle the switch bouncing. A more complex design could have been used to handle switch bouncing at a faster clock frequency but that was not necessary for this lab. When a key was pressed, it would set the enable signal for the FSM decoder to then update the input signals to the display. The FSM decoder completed the logic to decode the row and column into the digit pressed, and then used an enabled flip flop to update the two output digit signals. The task of driving the two displays was done by using a module to multiplex the switch inputs and then feed this signal into the seven segment display decoder module. The input multiplexer module would on every positive edge of the clock switch between outputing each switch signal. This output signal was then inputed into a module that decoded the signal into the corresponding signal to drive the LEDs of the display. Two enable signals were also output for transistors used to drive the displays. A testbench was created for the FSM, decoder, and lab3 top modules in order to test their functionality in simulation. The circuit for the design included the dual seven segment display, two PNP transistors for driving the display, and the keypad scanner. The seven segment displays would draw too much current from the FPGA pin, so a transistor was used to help supply current. Two PNP transistors were used, which were switched on and off by the enable signals to drive displaying either digit. Since the pins connected to the keypad would be floating when a button was not pressed, pull down resistors were used on these signals."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe sourcecode for the project can be found in the Github repository.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block Diagram\n\n\n\nFigure 1 shows the design implimented on the FPGA.\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic\n\n\n\nFigure 2 shows the circuit for the design. The LEDs were connected to current limiting resistors of 100 \\(\\Omega\\). These resistor values were solved for by solving for R in V = IR with the voltage found from the part data sheets and a desired current of around 8 mA found from the FPGA data sheet. With voltages of 1.2 and 1.3, 100 \\(\\Omega\\) resistors gave a current slightly above 8 mA. The same calculation was done using 3.3V to find the resistance of the resistors for the transistor base signal. 100 \\(\\Omega\\) resistors were used to pull the column pins to ground.\n\n\nState Transition Diagram\n\n\n\n\n\n\nFigure 3: State Transition Diagram\n\n\n\nFigure 3 shows the state transition diagam for the design’s FSM. The row checking sections are offset from the row pressed sections due to the synchronizer delaying the column input by two clock cycles. States 4, 5, 7, 8, 10, 11, 13, and 14 are the hold states to deal with switch bouncing.\n\n\nNext State Logic\n\n\n\nTable 1: Next State Logic\n\n\n\n\n\nstate\ncol_sync\nnext\n\n\n\n\ns0\n0000\ns1\n\n\ns0\n!(0000)\ns10\n\n\ns1\n0000\ns2\n\n\ns1\n!(0000)\ns13\n\n\ns2\n0000\ns3\n\n\ns2\n!(0000)\ns4\n\n\ns3\n0000\ns0\n\n\ns3\n!(0000)\ns7\n\n\ns4\nxxxx\ns5\n\n\ns5\nxxxx\ns6\n\n\ns6\n0000\ns1\n\n\ns6\n!(0000)\ns6\n\n\ns7\nxxxx\ns8\n\n\ns8\nxxxx\ns9\n\n\ns9\n0000\ns2\n\n\ns9\n!(0000)\ns9\n\n\ns10\nxxxx\ns11\n\n\ns11\nxxxx\ns12\n\n\ns12\n0000\ns3\n\n\ns12\n!(0000)\ns12\n\n\ns13\nxxxx\ns14\n\n\ns14\nxxxx\ns15\n\n\ns15\n0000\ns0\n\n\ns15\n!(0000)\ns15\n\n\n\n\n\n\nTable 1 shows the next state logic for the FSM of the design.\n\n\nOutput Logic\n\n\n\nTable 2: Output Logic\n\n\n\n\n\nState\nrow\nrow_pressed\nen\n\n\n\n\ns0\n0001\n0000\n0\n\n\ns1\n0010\n0000\n0\n\n\ns2\n0100\n0000\n0\n\n\ns3\n1000\n0000\n0\n\n\ns4\n0001\n0001\n1\n\n\ns5\n0001\n0001\n0\n\n\ns6\n0001\n0001\n0\n\n\ns7\n0010\n0010\n1\n\n\ns8\n0010\n0010\n0\n\n\ns9\n0010\n0010\n0\n\n\ns10\n0100\n0100\n1\n\n\ns11\n0100\n0100\n0\n\n\ns12\n0100\n0100\n0\n\n\ns13\n1000\n1000\n1\n\n\ns14\n1000\n1000\n0\n\n\ns15\n1000\n1000\n0\n\n\n\n\n\n\nTable 2 shows the output logic for the FSM of the design."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\n\n\n\nFigure 4: FSM Simulation\n\n\n\n\n\n\n\n\n\nFigure 5: FSM Decoder Simulation\n\n\n\n\n\n\n\n\n\nFigure 6: Lab 3 Top Simulation\n\n\n\nThe design met all intended objectives. Figure 4 shows the FSM of the design working in simulation. The rows switch as desired and the module handles an input correctly as seen in the image. Figure 5 shows the FSM decoder working as expected. The waves show the signals switching only when the enable signal is 1. Figure 6 shows the top module working as expected, seen by the correct row outputs and the multiplexed display signal.\n\n\nExample of Design\n\nIn addition to working in simulation, the design also worked in reality. The video above shows an example of the circuit working."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nThe FPGA was used to read the keypad scanner and display the last two digits pressed. I spent a total of 27 hours on this lab."
  },
  {
    "objectID": "posts/seventh-post.html",
    "href": "posts/seventh-post.html",
    "title": "Week 7",
    "section": "",
    "text": "This week of microps I mainly focused on my final project proposal with my partner. It is exciting to know have a solidified plan for the final project because it feels a lot more achievable then before. We found an individually addresable RGB LED strip in our lab that we can use for our project, and this will allow us to not only reduce the number of pins required to drive the board LEDs but also light up each square a different color with a single LED. I am excited about this because being able to use different colors this easily will make tasks such as lighting up squares in different colors much simpler than if individual LEDs were used. I anticipate my biggest struggle with the project being interfacing with the hall sensors to detect piece movement. The current lab we are working on uses SPI and we plan to use SPI to send the column data from the FPGA to the MCU in our design, so I still feel unsure about my abilities to use SPI in the most effective way. Based on how the class has gone so far, I expect after finishing the SPI lab to feel more confident about what I need to do for the project. I also do not have any experience using a DAC to play audio, so this could also be a source of struggle but I do not anticipate this being too complex."
  },
  {
    "objectID": "posts/eigth-post.html",
    "href": "posts/eigth-post.html",
    "title": "Lab 6 Reflection",
    "section": "",
    "text": "I think lab 6 was a good experience for me because it stressed to me the importance of attention to details. I would say it was probably the least logical thinking inducing lab, as most of it was just setting up an SPI transaction correctly. I did incur a fair amount of struggle time, mainly due to the head of the logic analyzer cable being finicky and not being precise about my breadboarded circuit. For a while, I was failing to get any output from the temperature chip showing on the oscilliscope. This was fixed by simply changing the pins on the logic analyzer head that I was using, which was bittersweet to find out. It was nice to know I was not going crazy and that the code was doing what I thought it was doing, and a less in magnitude amount of frustrating to have spent so much time trying to fix the issue without just trying new pins. After that, there was some point where the wires on my breadboard became unplugged and when I plugged the CIPO wire back in, I did so into pin 6 and not pin A6. This caused me to not be capturing the value on the MCU, even when I could see it on the logic analyzer. I was overall glad after this experience, as I do not think I will ever again make these same mistakes. Prior to this lab, I had not felt stuck in the same way I did during this lab so it was nice to be given an experience that will serve as a constant reminder to be precise about what I am doing."
  },
  {
    "objectID": "posts/fifth-post.html",
    "href": "posts/fifth-post.html",
    "title": "Week 5",
    "section": "",
    "text": "Last week our in class work focused on PCB design, and I found this very interesting as this was my first exposure to the subject and I always wondered how a circuit could be made into a PCB. I have had slight exposure to using CAD for modeling designs in E4, and this process felt similar to that. I enjoyed it as it felt nice to have to think in a slightly more creative manner in comparison to the type of thinking required for the labs. Because I would only ever need to design a PCB for a design that I know is succesful, I feel as if the design of the PCB would be a reward. The hardest thinking of the project would be over, and all that is left would be the fun part of deciding the best way to arrange things. Looking towards the final project, this makes me excited at the possibility of thinkging of a design where I would need to design a PCB for it."
  },
  {
    "objectID": "posts/fourth-post.html",
    "href": "posts/fourth-post.html",
    "title": "Week 4",
    "section": "",
    "text": "So far this has been the most I have worked on E155 in a week, but I found the work enjoyable. I was unable to complete lab 3 by Thursday, as in the beginning of the week I found myself struggling to read an input from the column. After about 15 hours of work on the lab, I kind of started over and tried rebuilding a new FSM where I slowly added pieces of functionality. This strategy worked for me as I was able to first pulse the rows correctly, then transfer to a desired state on a button press, and so on. I eventually got to a point where my design could correctly read a button press, but it would not display the numbers correctly on the display. At this point I stopped working on lab 3 and started working on lab 4. I found better luck on lab 4 than I did on lab 3 as I was able to complete the task in much less time. In my design for lab 4 I used the basic timers on the MCU, but I realized I could use the generic timer in a PWM function to generate the square wave which might be more accurate. I plan to use the rest of my time before lab 4 is due to test how accurate my design is and update it to use PWM if necessary. I restarted working on lab 3 today also, and was able to complete it. I found that my design was working as expected, I just needed to slow my clock down."
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "Week 2",
    "section": "",
    "text": "In this week of E155 I feel like I was able to finally knock off all of the rust I had devloped in my intermission from E85. In terms of doing the lab, I feel like I was able to get back in the groove of the softwares we had used in E85 and learn the new software introduced in this course. This was helpful in speeding up my overall lab process as I was able to spend more time doing the lab as opposed to trying to figure out or remember how to use a certain software. In addition to this, in class review and doing the first lab had helped me remember how to use verilog so I was able to enter the verilog design portion of this lab in the correct headspace of a hardware designer in contrast to my usual software design thoughts as a computer science major.\nIn class these week we began discussing the MCU we will be using in the course. This made me excited for the upcoming labs involving the MCU. Labs 1-3 involved only FPGA design, and Labs 4-6 will be focused around MCU design. After seeing myself transition from a very limited understanding of FPGA use to at least somewhat of an understanding after the first two labs, I am excited for this to happen again in relation to the MCU. I think right now one of the things limiting my ideation for the project is not knowing what I could do with an MCU, so I am eager to start using it so I can have a better idea of the design tools I could put to use in my project."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Luke Summers is a fourth year computer science major at Harvey Mudd College.\nFinal project for class can be found here."
  }
]